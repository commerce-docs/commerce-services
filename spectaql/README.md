# SpectaQL configuration

This directory contains SpectaQL configuration files for generating GraphQL API documentation.

## Configuration files

- `config-admin.yml` - Configuration for the Admin API (reference not currently implemented)
- `config-merchandising.yml` - Configuration for the Merchandising API (uses environment variables)
- `metadata-merchandising.json` - Metadata file that controls which queries and types appear in the Merchandising API reference
- `enhanced-schema.json` - Cached introspection result for offline builds (generated by `scripts/fetch-and-enhance-schema.js`)

## How it works

The Merchandising API documentation is generated by SpectaQL using **live introspection** against the GraphQL endpoint. The `metadata-merchandising.json` file filters the full schema down to only the relevant queries and their associated types.

### Documented queries

The metadata file is configured to include only these queries:

- `attributeMetadata`
- `categoryTree`
- `navigation`
- `productSearch`
- `products`
- `recommendations`
- `recommendationsByUnitIds`
- `refineProduct`
- `variants`

All other queries and their exclusively-referenced types are marked as `undocumented` and excluded from the generated output.

### Metadata file structure

The metadata file uses SpectaQL's metadata format with these sections:

- **`OBJECT.Query.fields`** — Marks unwanted queries as `undocumented: true`
- **`OBJECT.*`** — Marks unwanted Object types as `undocumented: true`
- **`INPUT_OBJECT.*`** — Marks unwanted Input types as `undocumented: true`
- **`ENUM.*`** — Marks unwanted Enum types as `undocumented: true`
- **`UNION.*`** — Marks unwanted Union types as `undocumented: true`
- **`INTERFACE.*`** — Marks unwanted Interface types as `undocumented: true`
- **`FIELD_ARGUMENT`** — Provides custom descriptions for query arguments (e.g., `categoryTree` and `navigation` arguments)

## Environment variables

The following environment variables are required. Set them in a `.env` file in the project root:

```bash
# Copy the example file
cp .env.example .env
```

| Variable | Description |
|---|---|
| `TENANT_ID` | Your Adobe Commerce tenant ID |
| `CATALOG_VIEW_ID` | Catalog view ID for the API context |

## Related scripts

| Script | Purpose |
|---|---|
| `scripts/fetch-and-enhance-schema.js` | Fetches the live schema and injects custom descriptions |
| `scripts/build-with-enhanced-schema.js` | End-to-end build: fetch schema, inject descriptions, run SpectaQL |
| `scripts/run-spectaql-with-cleanup.js` | Runs SpectaQL with automatic temp file cleanup |
| `scripts/generate-spectaql-config.js` | Generates a temp config with environment variables substituted |
| `scripts/inject-descriptions.js` | Core description injection logic (used by `fetch-and-enhance-schema.js`) |

## Build commands

### Standard build (live endpoint)

Uses live introspection to fetch the schema and applies metadata filtering:

```bash
# Build the documentation
yarn build:merchandising-api

# Or run in development mode with live preview
yarn dev:merchandising-api
```

During a standard build, SpectaQL:

1. Substitutes environment variables into a temp config file
2. Introspects the live GraphQL endpoint
3. Applies the metadata file to filter queries/types and inject descriptions
4. Generates `static/graphql-api/merchandising-api/index.html`
5. Cleans up the temp config file

### Enhanced build (with description injection)

The standard build uses the live schema as-is, so any query arguments that lack descriptions in the live schema appear blank. The enhanced build solves this by fetching the live schema, injecting the custom descriptions defined in `metadata-merchandising.json` (under `FIELD_ARGUMENT`), and then running SpectaQL against the enhanced schema.

```bash
node scripts/build-with-enhanced-schema.js
```

Use this build whenever `metadata-merchandising.json` includes custom descriptions that you want reflected in the generated API reference.

### Update the cached schema (for offline builds)

Fetches the current schema from the live endpoint and saves it to `enhanced-schema.json`:

```bash
node scripts/fetch-and-enhance-schema.js
```

To use the cached schema instead of the live endpoint, edit `config-merchandising.yml`:

1. Uncomment: `introspectionFile: spectaql/enhanced-schema.json`
2. Comment out the `url` and `headers` lines

## Update the API reference

If the schema or metadata descriptions change, rebuild and test the API reference locally:

1. Create a branch from `main`.
2. If you updated custom descriptions in `metadata-merchandising.json`, use the enhanced build:

   ```bash
   node scripts/build-with-enhanced-schema.js
   ```

   Otherwise, use the standard build: `yarn dev:merchandising-api`
3. Open `static/graphql-api/merchandising-api/index.html` in your browser and verify the output.
4. Commit the updated `index.html` and `enhanced-schema.json` files.
5. After updates are approved, a documentation team member merges the PR and publishes the updates to the [developer site](https://developer.adobe.com/commerce/services/merchandising-services/).

### Prerequisites

- Node.js matching the version in [.nvmrc](https://github.com/AdobeDocs/commerce-services/blob/main/.nvmrc)
- Yarn

## Generated output

The build generates `static/graphql-api/merchandising-api/index.html`, which is embedded in the documentation site using the Adobe I/O theme's `frameSrc` feature.

## Notes

- The `${TENANT_ID}` placeholder in the YAML config is processed by `scripts/generate-spectaql-config.js`, which creates a temporary `config-merchandising-temp.yml` file
- Temporary config files are automatically cleaned up after the build completes
- The `.env` file is in `.gitignore` to prevent committing sensitive information
